/*
 * datagen-species
 *
 * Usage: datagen-species <OUT_DIR> <ROOT_DIR> <FORMS_REGISTRY> <TUTOR_SCHEMA>
 *
 * This program is responsible for generating data archive from species data files
 * (res/pokemon/<species>/data.json). Individual files to be polled for packing are
 * drawn from an environment var SPECIES, which should be a semicolon-delimited list
 * of subdirectories of res/pokemon.
 *
 * <FORMS_REGISTRY> is expected to be a listing of additional subdirectories
 * belonging to individual species which have distinct data files. These special
 * forms have their own base stats, types, level-up learnsets, etc., as any base
 * species form would.
 *
 * <TUTOR_SCHEMA> is expected to be a JSON file defining the listing of moves that
 * can be taught by a given move tutor, agnostic of species. This file is only
 * consulted to restrict the set of valid moves in a species' tutorable learnset.
 *
 * The following files are generated by this program:
 *   - pl_personal.narc
 *   - evo.narc
 *   - wotbl.narc
 *   - ppark.narc
 *   - height.narc
 *   - pl_poke_data.narc
 *   - tutorable_moves.h
 *   - species_learnsets_by_tutor.h
 *   - species_footprints.h
 */
#include <cstdlib>
#include <cstring>
#include <filesystem>
#include <iostream>

// This attribute is useful when working with structures that have an element
// which must be word-aligned. For an example (and reasoning), see
// `SpeciesEvolutionList` in `datagen_species.cpp`.
#define ALIGN_4 __attribute__((aligned(4)))

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef int8_t s8;
typedef int16_t s16;
typedef int32_t s32;
typedef bool BOOL;

#define TRUE  true
#define FALSE false

#include "struct_defs/archived_poke_sprite_data.h"
#include "struct_defs/species.h"

#include "json.h"
#include "narc.h"
#include "operators.h"
#include "utils.h"

namespace fs = std::filesystem;

struct Args {
    fs::path indir;
    fs::path outdir;
    fs::path forms;
    fs::path tutors;
};

const Args parseargs(const int argc, const char **argv);
const SpeciesData parsepersonal(const Json &data);

int main(int argc, const char **argv)
{
    const auto args = parseargs(argc - 1, argv + 1);
    const auto entries = splitenv("SPECIES") + readlines(args.forms);

    Narc personal, evo, wotbl, height, ppark, pl_poke_data;
    std::vector<SpeciesPalPark> pparkvec;
    std::vector<ArchivedPokeSpriteData> plpokevec;

    for (auto &entry : entries) {
        Json data(args.indir / entry / "data.json");

        personal << parsepersonal(data);
    }

    // prepare persistent objects for storage
    // iterate over all entries
    // generate output archives and code-tables
}

void usage(std::ostream &out)
{
    out << "datagen-species - Generate species-data archives and code tables\n";
    out << "\n";
    out << "Usage: datagen-species OUT_DIR IN_DIR FORMS_REGISTRY TUTOR_REGISTRY\n";
    out << "\n";
    out << "Generates data archives from species data files using a semicolon-delimited\n"
        << "list from an environment variable SPECIES to walk a list of subdirectories.\n"
        << "Subdirectories must contain `data.json`, which contains the species data.\n";

    out.flush();
}

const Args parseargs(const int argc, const char **argv)
{
    if (argc == 0 || std::strncmp(argv[0], "-h", 2) == 0 || std::strncmp(argv[0], "--help", 6) == 0) {
        usage(std::cout);
        std::exit(EXIT_SUCCESS);
    }

    if (argc < 4) {
        usage(std::cerr);
        std::exit(EXIT_FAILURE);
    }

    return {
        .indir = argv[1],
        .outdir = argv[0],
        .forms = argv[2],
        .tutors = argv[3],
    };
}

const SpeciesData parsepersonal(const Json &data)
{
    SpeciesData species;

    return species;
}

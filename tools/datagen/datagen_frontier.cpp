/*
 * datagen-frontier
 *
 * Usage: datagen-frontier <OUT_DIR> <TRAINER_DATA_DIR> <POKEMON_DATA_DIR>
 *
 * The following files are generated by this program:
 *   - pl_btdtr.narc
 *   - pl_btdpm.narc
 */

#include <cstdlib>
#include <exception>
#include <iostream>
#include <map>
#include <vector>

#include "datagen.h"

#define POKEPLATINUM_GENERATED_ENUM
#define POKEPLATINUM_GENERATED_LOOKUP
#define POKEPLATINUM_GENERATED_LOOKUP_IMPL

#include "generated/items.h"
#include "generated/moves.h"
#include "generated/natures.h"
#include "generated/species.h"
#include "generated/trainer_classes.h"

#include "struct_defs/battle_frontier_pokemon_data.h"

std::map<std::string, int, std::less<>> MapSetnameToId;

static void BuildFrontierMonLookupTable(const std::vector<std::string> pokemonRegistry)
{
    for (int index = 0; index < pokemonRegistry.size(); index++) {
        MapSetnameToId[pokemonRegistry[index]] = index;
    }
}

static void PackFrontierTrainer(const rapidjson::Document &doc, NarcBuilder &builder)
{
    auto sets = doc["availableSets"].GetArray();
    int dataSize = 2 + sets.Size();

    std::vector<u16> trdata;
    trdata.resize(dataSize, 0);
    trdata[0] = LookupConst(doc["class"].GetString(), TrainerClass);

    for (int i = 0; i < sets.Size(); i++) {
        const auto &value = std::string(sets[i].GetString());
        if (value != "none_1") trdata[1]++;

        trdata[2 + i] = MapSetnameToId[value];
    }

    builder.append(reinterpret_cast<std::byte *>(trdata.data()), trdata.size() * sizeof(u16));
}

static void ParseMoves(const rapidjson::Value &moves, BattleFrontierPokemonData &data)
{
    for (int i = 0; i < LEARNED_MOVES_MAX; i++) {
        data.moves[i] = LookupConst(moves.GetArray()[i].GetString(), Move);
    }
}

static void ParseEvFlags(const rapidjson::Value &evFlags, BattleFrontierPokemonData &data)
{
    data.evFlags = 0;
    if (evFlags["hp"].GetBool()) {
        data.evFlags += 1 << 0;
    }
    if (evFlags["attack"].GetBool()) {
        data.evFlags += 1 << 1;
    }
    if (evFlags["defense"].GetBool()) {
        data.evFlags += 1 << 2;
    }
    if (evFlags["speed"].GetBool()) {
        data.evFlags += 1 << 3;
    }
    if (evFlags["special_attack"].GetBool()) {
        data.evFlags += 1 << 4;
    }
    if (evFlags["special_defense"].GetBool()) {
        data.evFlags += 1 << 5;
    }
}

static BattleFrontierPokemonData ParseFrontierPokemon(const rapidjson::Document &doc)
{
    BattleFrontierPokemonData data = {};
    data.species = LookupConst(doc["species"].GetString(), Species);
    ParseMoves(doc["moves"], data);
    ParseEvFlags(doc["evFlags"], data);
    data.nature = LookupConst(doc["nature"].GetString(), Nature);
    data.item = LookupConst(doc["item"].GetString(), Item);
    data.form = doc["form"].GetUint();

    return data;
}

static void LoadJson(rapidjson::Document &doc, fs::path filePath)
{
    std::string json = ReadWholeFile(filePath);
    rapidjson::ParseResult ok = doc.Parse(json.c_str(), json.length());
    if (!ok) {
        ReportJsonError(ok, json, filePath);
        std::exit(EXIT_FAILURE);
    }
}

int main(int argc, char **argv)
{
    if (argc == 1) {
        return EXIT_SUCCESS;
    }

    fs::path outputRoot = argv[1];
    fs::path trainerDataRoot = argv[2];
    fs::path pokemonDataRoot = argv[3];

    std::vector<std::string> trainerRegistry = ReadRegistryEnvVar("TRAINERS");
    std::vector<std::string> pokemonRegistry = ReadRegistryEnvVar("POKEMONS");

    BuildFrontierMonLookupTable(pokemonRegistry);

    NarcBuilder pl_btdtr { trainerRegistry.size() };
    NarcBuilder pl_btdpm { pokemonRegistry.size() };
    rapidjson::Document namesTextBank(rapidjson::kObjectType);
    namesTextBank.AddMember("key", 26501, namesTextBank.GetAllocator());
    rapidjson::Document messagesTextBank(rapidjson::kObjectType);
    messagesTextBank.AddMember("key", 35392, messagesTextBank.GetAllocator());

    rapidjson::Document doc;
    rapidjson::Value nameMessages(rapidjson::kArrayType);
    rapidjson::Value trainerMessages(rapidjson::kArrayType);
    for (auto &trainerStem : trainerRegistry) {
        fs::path trainerDataPath = trainerDataRoot / (trainerStem + ".json");
        LoadJson(doc, trainerDataPath);

        try {
            PackFrontierTrainer(doc, pl_btdtr);

            std::string trName = doc["name"].GetString();
            rapidjson::Value nameMessage(rapidjson::kObjectType);

            std::string id = "FrontierTrainerNames_Text_" + trainerStem;
            rapidjson::Value idValue(rapidjson::kStringType);
            idValue.SetString(id.c_str(), static_cast<rapidjson::SizeType>(id.length()), namesTextBank.GetAllocator());
            nameMessage.AddMember("id", idValue, namesTextBank.GetAllocator());

            rapidjson::Value string(rapidjson::kStringType);
            string.SetString(trName.c_str(), static_cast<rapidjson::SizeType>(trName.length()), namesTextBank.GetAllocator());
            nameMessage.AddMember("en_US", string, namesTextBank.GetAllocator());

            nameMessages.PushBack(nameMessage, namesTextBank.GetAllocator());

            for (const auto &member : doc["messages"].GetArray()) {
                rapidjson::Value trainerMessage(rapidjson::kObjectType);

                std::string type = member["type"].GetString();
                std::string id = "FrontierTrainerMessages_Text_" + trainerStem + "_" + type;
                rapidjson::Value idValue(rapidjson::kStringType);
                idValue.SetString(id.c_str(), static_cast<rapidjson::SizeType>(id.length()), messagesTextBank.GetAllocator());
                trainerMessage.AddMember("id", idValue, messagesTextBank.GetAllocator());

                CopyMessage(member, trainerMessage, messagesTextBank.GetAllocator());

                trainerMessages.PushBack(trainerMessage, messagesTextBank.GetAllocator());
            }
        } catch (const std::exception &e) {
            std::cerr << e.what() << std::endl;
            std::exit(EXIT_FAILURE);
        }
    }
    namesTextBank.AddMember("messages", nameMessages, namesTextBank.GetAllocator());
    messagesTextBank.AddMember("messages", trainerMessages, messagesTextBank.GetAllocator());

    for (auto &pokemonStem : pokemonRegistry) {
        fs::path pokemonDataPath = pokemonDataRoot / (pokemonStem + ".json");
        LoadJson(doc, pokemonDataPath);

        try {
            BattleFrontierPokemonData pmdata = ParseFrontierPokemon(doc);
            pl_btdpm.append(reinterpret_cast<std::byte *>(&pmdata), sizeof(pmdata));
        } catch (const std::exception &e) {
            std::cerr << e.what() << std::endl;
            std::exit(EXIT_FAILURE);
        }
    }

    pl_btdtr.write(outputRoot / "pl_btdtr.narc");
    pl_btdpm.write(outputRoot / "pl_btdpm.narc");

    char writeBuffer[65536];

    FILE *fp = fopen((outputRoot / "frontier_trainer_names.json").string().c_str(), "w");
    rapidjson::FileWriteStream namesStream(fp, writeBuffer, sizeof(writeBuffer));
    rapidjson::Writer<rapidjson::FileWriteStream> namesWriter(namesStream);
    namesTextBank.Accept(namesWriter);
    fclose(fp);

    fp = fopen((outputRoot / "frontier_trainer_messages.json").string().c_str(), "w");
    rapidjson::FileWriteStream messagesStream(fp, writeBuffer, sizeof(writeBuffer));
    rapidjson::Writer<rapidjson::FileWriteStream> messagesWriter(messagesStream);
    messagesTextBank.Accept(messagesWriter);
    fclose(fp);
    return EXIT_SUCCESS;
}
